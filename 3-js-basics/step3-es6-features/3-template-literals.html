<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ES6 템플릿 리터럴</title>
</head>
<body>
ES6 템플릿 리터럴: 백틱(`)과 ${} 사용, 문자열 연결이 쉬워짐
<br><br>

<button onclick="basicUsage()">기본 사용법</button>
<button onclick="multilineStrings()">여러 줄 문자열</button>
<button onclick="expressions()">표현식 삽입</button>
<button onclick="practicalExample()">실무 예제</button>

<script>
    // 🎯 학습 목표: 템플릿 리터럴로 문자열 처리 마스터하기
    // 💡 핵심 개념:
    // - 백틱(`)으로 문자열을 감싸고 ${}로 변수나 표현식 삽입
    // - + 연산자 없이도 문자열과 변수를 자연스럽게 조합
    // - 여러 줄 문자열을 \n 없이 작성 가능
    // - React JSX, Vue 템플릿, Node.js에서 필수 문법
    
    function basicUsage() {
        console.log("=== 기본 사용법 ===");
        
        const name = "김철수";
        const age = 25;
        const city = "서울";
        
        // 🔍 기존 방식: + 연산자로 문자열 연결 (번거롭고 실수하기 쉬움)
        // 따옴표와 + 기호가 많아서 가독성이 떨어지고, 공백 처리도 신경써야 함
        const oldWay = "안녕하세요, " + name + "님! 나이는 " + age + "세이고 " + city + "에 살고 있습니다.";
        
        // ✨ 템플릿 리터럴 방식: 백틱과 ${}를 사용해서 자연스럽게 변수 삽입
        // 문자열 안에 변수가 들어갈 자리에 ${}를 쓰고 그 안에 변수명 작성
        // 훨씬 읽기 쉽고 실제 출력될 모양과 비슷하게 코드 작성 가능
        const newWay = `안녕하세요, ${name}님! 나이는 ${age}세이고 ${city}에 살고 있습니다.`;
        
        console.log("기존 방식:", oldWay);
        console.log("템플릿 리터럴:", newWay);
        
        // 🎯 다양한 데이터 타입 삽입: 문자열, 숫자, 불린, 객체 속성 모두 가능
        // ${}안에는 변수뿐만 아니라 객체 속성, 메서드 호출, 삼항 연산자 등 모든 표현식 사용 가능
        const product = { name: "노트북", price: 1200000 };
        const isOnSale = true;
        
        const productInfo = `상품: ${product.name}, 가격: ${product.price.toLocaleString()}원, 할인: ${isOnSale ? '적용' : '미적용'}`;
        console.log("상품 정보:", productInfo);
        
        // 💡 실무 팁: toLocaleString()으로 숫자 천 단위 구분, 삼항 연산자로 조건부 텍스트
        
        alert("콘솔에서 문자열 생성 결과를 확인하세요!");
    }
    
    function multilineStrings() {
        console.log("=== 여러 줄 문자열 ===");
        
        const orderNumber = "ORD-2024-001";
        const customerName = "이영희";
        const items = ["스마트폰", "케이스", "충전기"];
        
        // 🔍 기존 방식: \n으로 줄바꿈하고 + 연산자로 연결 (매우 번거로움)
        // 줄바꿈할 때마다 \n을 넣어야 하고, 들여쓰기도 보기 어려움
        // 실제 출력 모양을 상상하기 어렵고 수정도 복잡함
        const oldReceipt = "주문 확인서\n" +
                          "===========\n" +
                          "주문번호: " + orderNumber + "\n" +
                          "고객명: " + customerName + "\n" +
                          "주문 상품:\n" +
                          "- " + items.join("\n- ");
        
        // ✨ 템플릿 리터럴: 실제 출력 모양 그대로 작성 가능
        // Enter로 줄바꿈하면 실제로도 줄바꿈됨 (\n 불필요)
        // 들여쓰기도 그대로 반영되어 코드만 봐도 출력 모양을 알 수 있음
        // 배열 메서드와 조합해서 동적으로 목록 생성도 쉬움
        const newReceipt = `주문 확인서
===========
주문번호: ${orderNumber}
고객명: ${customerName}
주문 상품:
${items.map(item => `- ${item}`).join('\n')}

배송 안내:
- 결제 완료 후 2-3일 내 배송
- 무료배송 (3만원 이상)`;
        
        console.log("기존 방식:\n" + oldReceipt);
        console.log("\n템플릿 리터럴:\n" + newReceipt);
        
        // 🌐 HTML 생성 예제: React나 Vue 없이도 동적 HTML 생성 가능
        // 서버 사이드 렌더링, 이메일 템플릿, 동적 웹페이지 생성에 매우 유용
        // 백엔드 Node.js에서 HTML 응답 만들 때도 자주 사용
        const htmlCard = `
<div class="user-card">
    <h3>${customerName}님의 주문</h3>
    <p>주문번호: <strong>${orderNumber}</strong></p>
    <ul>
        ${items.map(item => `<li>${item}</li>`).join('')}
    </ul>
</div>`;
        
        console.log("HTML 생성:", htmlCard);
        
        // 💡 실무 활용:
        // - 이메일 템플릿 (주문 확인, 비밀번호 재설정 등)
        // - PDF 문서 생성 시 텍스트 구성
        // - 로그 메시지 포맷팅
        // - SQL 쿼리 동적 생성
        
        alert("콘솔에서 여러 줄 문자열 결과를 확인하세요!");
    }
    
    function expressions() {
        console.log("=== 표현식 삽입 ===");
        
        const price = 50000;
        const quantity = 3;
        const taxRate = 0.1;
        
        // 🧮 산술 연산: ${}안에서 직접 계산 가능
        // 별도 변수 선언 없이 바로 계산 결과를 문자열에 삽입
        console.log(`소계: ${price * quantity}원`);
        
        // 🔧 함수 호출: ${}안에서 함수 실행하고 결과값 삽입
        // 데이터 포맷팅 함수를 만들어두고 템플릿에서 바로 호출하는 패턴이 일반적
        function formatPrice(amount) {
            return amount.toLocaleString() + "원";
        }
        console.log(`정가: ${formatPrice(price * quantity)}`);
        
        // ❓ 조건부 표현식: 삼항 연산자로 조건에 따라 다른 텍스트 표시
        // if문은 사용 불가하고 삼항 연산자만 가능 (표현식만 허용되기 때문)
        // 배송비 무료 조건, 재고 상태, 회원 등급별 메시지 등에서 자주 사용
        console.log(`배송비: ${price * quantity >= 30000 ? '무료' : '3000원'}`);
        
        // 🔗 배열 메서드: map, filter, join 등을 조합해서 동적 목록 생성
        // 카테고리 경로, 태그 목록, 메뉴 구성 등에서 매우 유용
        const categories = ["전자제품", "컴퓨터", "노트북"];
        console.log(`카테고리: ${categories.join(" > ")}`); // "전자제품 > 컴퓨터 > 노트북"
        
        // 📊 복잡한 계산과 포맷팅: 여러 함수 호출을 조합해서 완성된 문서 생성
        // 실제 업무에서는 이런 식으로 견적서, 청구서, 리포트 등을 생성
        const finalPrice = price * quantity * (1 + taxRate);
        const receipt = `
최종 계산서:
- 단가: ${formatPrice(price)}
- 수량: ${quantity}개
- 소계: ${formatPrice(price * quantity)}
- 세금: ${formatPrice(price * quantity * taxRate)}
- 합계: ${formatPrice(finalPrice)}`;
        
        console.log(receipt);
        
        // 💡 주의사항:
        // - ${}안에는 표현식만 가능 (문장은 불가)
        // - if문, for문 등은 직접 사용 불가 (삼항 연산자, 배열 메서드로 대체)
        // - 복잡한 로직은 함수로 분리하고 템플릿에서는 호출만
        
        alert("콘솔에서 다양한 표현식 결과를 확인하세요!");
    }
    
    function practicalExample() {
        console.log("=== 실무 활용 예제 ===");
        
        // 🌐 API URL 동적 생성: RESTful API 호출 시 매우 일반적인 패턴
        // 쿼리 파라미터가 많을 때 URLSearchParams보다 간단하게 URL 구성 가능
        // 백엔드 API 호출, 외부 서비스 연동 시 필수 기술
        const baseURL = "https://api.example.com";
        const endpoint = "products";
        const category = "electronics";
        const minPrice = 10000;
        const maxPrice = 100000;
        
        const apiURL = `${baseURL}/${endpoint}?category=${category}&minPrice=${minPrice}&maxPrice=${maxPrice}`;
        console.log("API URL:", apiURL);
        // 결과: "https://api.example.com/products?category=electronics&minPrice=10000&maxPrice=100000"
        
        // 📧 이메일 템플릿: 실제 서비스에서 사용자에게 보내는 이메일 형식
        // 주문 확인, 비밀번호 재설정, 프로모션 메일 등에서 핵심 기술
        // Node.js 백엔드에서 Nodemailer와 함께 사용하는 일반적인 패턴
        const user = { name: "박고객", email: "customer@example.com" };
        const order = { 
            id: "ORD-001", 
            total: 85000,
            items: [
                { name: "무선마우스", price: 35000 },
                { name: "키보드", price: 50000 }
            ]
        };
        
        const emailTemplate = `
안녕하세요, ${user.name}님!

주문이 완료되었습니다.

📦 주문 정보
주문번호: ${order.id}
${order.items.map(item => `• ${item.name}: ${item.price.toLocaleString()}원`).join('\n')}

💰 결제 정보
총 금액: ${order.total.toLocaleString()}원
배송비: ${order.total >= 50000 ? '무료' : '3,000원'}

감사합니다!`;
        
        console.log("이메일 템플릿:", emailTemplate);
        
        // 🎨 CSS-in-JS 스타일: React styled-components, emotion 등에서 사용되는 패턴
        // 동적 스타일링, 테마 변경, 반응형 디자인에서 매우 유용
        // JavaScript 변수를 CSS에 직접 반영할 수 있어서 매우 강력함
        const theme = { primary: "#3498db", padding: "10px", fontSize: "14px" };
        const isLarge = true;
        
        const cssStyle = `
.button {
    background-color: ${theme.primary};
    padding: ${theme.padding};
    font-size: ${isLarge ? '16px' : theme.fontSize};
    border: none;
    border-radius: 4px;
    color: white;
    transition: all 0.3s ease;
}

.button:hover {
    background-color: ${theme.primary}dd; /* 투명도 추가 */
    transform: translateY(-1px);
}`;
        
        console.log("CSS 스타일:", cssStyle);
        
        // 📋 로그 메시지 포맷팅: 디버깅, 모니터링에서 필수
        // 서버 로그, 에러 추적, 성능 모니터링 등에서 구조화된 로그 생성
        function createLogMessage(level, module, message, data = null) {
            const timestamp = new Date().toISOString();
            return `[${timestamp}] ${level.toUpperCase()} [${module}]: ${message}${
                data ? `\n추가 정보: ${JSON.stringify(data, null, 2)}` : ''
            }`;
        }
        
        const logMessage = createLogMessage('error', 'PaymentService', '결제 처리 실패', {
            orderId: 'ORD-001',
            amount: 50000,
            errorCode: 'INSUFFICIENT_FUNDS'
        });
        console.log("로그 메시지:", logMessage);
        
        // 📊 보고서 템플릿: 자동화된 리포트 생성
        // 일일 매출 보고서, 성능 분석 보고서, 사용자 통계 등에서 활용
        const salesData = {
            date: '2024-03-15',
            totalSales: 1250000,
            orderCount: 47,
            topProduct: '무선 헤드폰',
            avgOrderValue: Math.round(1250000 / 47)
        };
        
        const salesReport = `
📈 일일 매출 보고서 - ${salesData.date}

💰 매출 현황:
- 총 매출액: ${salesData.totalSales.toLocaleString()}원
- 주문 건수: ${salesData.orderCount}건
- 평균 주문가: ${salesData.avgOrderValue.toLocaleString()}원

🏆 인기 상품: ${salesData.topProduct}

${salesData.totalSales > 1000000 ? '🎉 목표 매출 달성!' : '📊 목표 매출 미달성'}`;
        
        console.log("매출 보고서:", salesReport);
        
        // 💡 실무에서 템플릿 리터럴이 빛나는 순간:
        // 1. 동적 이메일/SMS 발송 시스템
        // 2. PDF 문서 자동 생성
        // 3. API 응답 메시지 구성
        // 4. 로그 시스템 구축
        // 5. 동적 SQL 쿼리 생성 (단, SQL 인젝션 주의!)
        // 6. React/Vue 컴포넌트의 동적 스타일링
        // 7. 설정 파일 자동 생성
        
        alert("콘솔에서 실무 활용 예제를 확인하세요!");
    }
</script>
</body>
</html>